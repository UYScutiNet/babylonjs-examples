<html lang="en">
  <head>
    <title>Yuka | Navmesh with Spatial Index and Tasks<</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="../../../css/styles.css" />
    <link rel="shortcut icon" type="image/x-icon" href="https://mugen87.github.io/yuka/favicon.ico" />

    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  </head>
  <body>
    <section id="loading-screen">
      <div class="spinner">
        <div class="rect1"></div>
        <div class="rect2"></div>
        <div class="rect3"></div>
        <div class="rect4"></div>
        <div class="rect5"></div>
      </div>
    </section>
    <canvas id="renderCanvas" style="width: 100%; height: 100%; touch-action: none"></canvas>

    <section id="info">
      <p>
        Navigation Mesh with Spatial Index and Tasks <br />
        Active Game Entities: <span id="entityCount"></span><br />
        Convex Regions of NavMesh: <span id="regionCount"></span><br />
        Partitions of Spatial Index: <span id="partitionCount"></span><br />
      </p>
    </section>

    <script type="module">
      import * as YUKA from '../../../../lib/yuka.module.js'
      import * as DAT from 'https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.module.js'

      import { createGraphHelper } from '../../graph/GraphHelper.js'
      import { createCellSpaceHelper } from '../common/CellSpacePartitioningHelper.js'
      import { createConvexRegionHelper } from '../common/NavMeshHelper.js'

      import { CustomVehicle } from './src/CustomVehicle.js'
      import { PathPlanner } from './src/PathPlanner.js'

      let engine,
        scene,
        camera,
        pathHelper,
        pathHelperParent,
        graphHelper,
        navMeshGroup,
        vehicleMesh,
        vehicleMeshes = []

      let entityManager, time, pathPlanner

      const entityMatrix = new BABYLON.Matrix()

      const vehicleCount = 100
      const vehicles = []
      const pathHelpers = []

      const params = {
        showNavigationPaths: false,
        showRegions: false,
        showSpatialIndex: false,
      }

      let spatialIndexHelper
      let regionHelper

      init()

      function init() {
        const canvas = document.getElementById('renderCanvas')
        engine = new BABYLON.Engine(canvas, true, {}, true)

        scene = new BABYLON.Scene(engine)
        scene.clearColor = new BABYLON.Color3(0, 0, 0)
        scene.useRightHandedSystem = true

        camera = new BABYLON.ArcRotateCamera(
          'camera',
          BABYLON.Tools.ToRadians(40),
          BABYLON.Tools.ToRadians(40),
          90,
          BABYLON.Vector3.Zero(),
          scene
        )

        camera.target = new BABYLON.Vector3(0, 0, 0)
        camera.attachControl(canvas, true)

        new BABYLON.HemisphericLight('light', new BABYLON.Vector3(1, 1, 0), scene)
        new BABYLON.DirectionalLight('dir-light', new BABYLON.Vector3(1, 1, 0), scene)

        // dat.gui
        const gui = new DAT.GUI({ width: 400 })

        gui
          .add(params, 'showNavigationPaths', 1, 30)
          .name('show navigation paths')
          .onChange((value) => {
            pathHelperParent.setEnabled(value)
          })

        gui
          .add(params, 'showRegions', 1, 30)
          .name('show regions')
          .onChange((value) => {
            regionHelper.setEnabled(value)
          })

        gui
          .add(params, 'showSpatialIndex', 1, 30)
          .name('show spatial index')
          .onChange((value) => {
            spatialIndexHelper.setEnabled(value)
          })

        gui.open()

        //

        window.addEventListener('resize', onWindowResize, false)

        BABYLON.SceneLoader.ImportMesh(null, 'model/', 'level.glb', scene, (meshes) => {
          meshes[0].rotation = new BABYLON.Vector3(0, Math.PI, 0)

          // 3D assets are loaded, now load nav mesh
          const loader = new YUKA.NavMeshLoader()
          loader.load('../common/navmeshes/complex/navmesh.glb').then((navigationMesh) => {
            // visualize convex regions

            regionHelper = createConvexRegionHelper(navigationMesh)
            regionHelper.setEnabled(false)

            entityManager = new YUKA.EntityManager()
            time = new YUKA.Time()

            pathPlanner = new PathPlanner(navigationMesh)

            // setup spatial index

            const width = 100,
              height = 40,
              depth = 75
            const cellsX = 20,
              cellsY = 5,
              cellsZ = 20

            navigationMesh.spatialIndex = new YUKA.CellSpacePartitioning(width, height, depth, cellsX, cellsY, cellsZ)
            navigationMesh.updateSpatialIndex()

            spatialIndexHelper = createCellSpaceHelper(navigationMesh.spatialIndex, scene)
            spatialIndexHelper.setEnabled(false)

            // create vehicles
            const vehicleMeshPrefab = BABYLON.MeshBuilder.CreateCylinder(
              'cone',
              { height: 1, diameterTop: 0, diameterBottom: 0.5 },
              scene
            )
            vehicleMeshPrefab.rotation.x = Math.PI * 0.5
            vehicleMeshPrefab.bakeCurrentTransformIntoVertices()

            const vehicleMeshMaterial = new BABYLON.StandardMaterial('vehicle', scene)
            vehicleMeshMaterial.emissiveColor = BABYLON.Color3.Red()
            vehicleMeshMaterial.disableLighting = true
            vehicleMeshPrefab.material = vehicleMeshMaterial

            pathHelperParent = new BABYLON.TransformNode('path-helper-parent', scene)
            pathHelperParent.setEnabled(false)

            for (let i = 0; i < vehicleCount; i++) {
              const vehicleMesh = vehicleMeshPrefab.clone(`vehixle-${i}`)
              vehicleMeshes[i] = vehicleMesh

              const pathHelper = new BABYLON.MeshBuilder.CreateLines(
                `path-helper`,
                {
                  points: [],
                  updatable: true,
                },
                scene
              )
              pathHelper.parent = pathHelperParent
              pathHelpers.push(pathHelper)

              // vehicle

              const vehicle = new CustomVehicle()
              vehicle.navMesh = navigationMesh
              vehicle.maxSpeed = 1.5
              vehicle.maxForce = 10

              const toRegion = vehicle.navMesh.getRandomRegion()
              vehicle.position.copy(toRegion.centroid)
              vehicle.toRegion = toRegion

              const followPathBehavior = new YUKA.FollowPathBehavior()
              followPathBehavior.nextWaypointDistance = 0.5
              followPathBehavior.active = false
              vehicle.steering.add(followPathBehavior)

              entityManager.add(vehicle)
              vehicles.push(vehicle)
            }

            // update UI

            const entityCount = document.getElementById('entityCount')
            entityCount.textContent = vehicleCount

            const regionCount = document.getElementById('regionCount')
            regionCount.textContent = navigationMesh.regions.length

            const partitionCount = document.getElementById('partitionCount')
            partitionCount.textContent = navigationMesh.spatialIndex.cells.length

            const loadingScreen = document.getElementById('loading-screen')

            loadingScreen.classList.add('fade-out')
            loadingScreen.addEventListener('transitionend', onTransitionEnd)

            //

            animate()
          })
        })
      }

      function onPathFound(vehicle, path) {
        // update path helper

        const index = vehicles.indexOf(vehicle)
        let pathHelper = pathHelpers[index]

        // TODO: do not dispose, but update the lines
        if (pathHelper) {
          pathHelper.dispose()
        }
        pathHelper = new BABYLON.MeshBuilder.CreateLines(
          `path-helper`,
          {
            points: path,
            updatable: true,
          },
          scene
        )
        pathHelper.parent = pathHelperParent
        pathHelper.color = BABYLON.Color3.Red()

        // update path and steering

        const followPathBehavior = vehicle.steering.behaviors[0]
        followPathBehavior.active = true
        followPathBehavior.path.clear()

        for (const point of path) {
          followPathBehavior.path.add(point)
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()

        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function animate() {
        requestAnimationFrame(animate)
        updatePathfinding()

        const delta = time.update().getDelta()
        entityManager.update(delta)
        pathPlanner.update()
        updateInstancing()

        scene.render()
      }

      function updatePathfinding() {
        for (let i = 0, l = vehicles.length; i < l; i++) {
          const vehicle = vehicles[i]

          if (vehicle.currentRegion === vehicle.toRegion) {
            vehicle.fromRegion = vehicle.toRegion
            vehicle.toRegion = vehicle.navMesh.getRandomRegion()

            const from = vehicle.position
            const to = vehicle.toRegion.centroid

            pathPlanner.findPath(vehicle, from, to, onPathFound)
          }
        }
      }

      let updateFlag = 1
      function updateInstancing() {
        for (let i = 0, l = vehicles.length; i < l; i++) {
          const vehicle = vehicles[i]
          vehicle.worldMatrix.toArray(entityMatrix.m)

          const vehicleMesh = vehicleMeshes[i]
          const matrix = vehicleMesh.getWorldMatrix()
          matrix.copyFrom(entityMatrix)
          matrix.updateFlag = updateFlag++
        }
      }

      function onTransitionEnd(event) {
        event.target.remove()
      }
    </script>
  </body>
</html>
